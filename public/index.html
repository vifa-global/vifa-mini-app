require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const { Telegraf } = require('telegraf');
const { TwitterApi } = require('twitter-api-v2');  // Add this line
const { google } = require('googleapis');


// Constants
const PORT = process.env.PORT || 10000; // Let Render decide
const app = express();


// ======================
// CORS MIDDLEWARE (ADD HERE)
// ======================
const cors = require('cors');
app.use(cors({
  origin: [
    'https://vifa-mini-app-frontend.onrender.com', // Your frontend
    'http://localhost:3000',                      // Local development
  ],
  credentials: true // Enable if using cookies/auth
}));


// Add this line (replace 12345 with your actual Telegram user ID)
const ADMIN_IDS = [12345, 8183350482]; // Your ID + VIFA Global's ID


// MongoDB Schema
const userSchema = new mongoose.Schema({
  userId: { type: Number, unique: true },
  points: { type: Number, default: 0 },
  lastCheckIn: Date,
  completedTasks: {
    twitterFollow: { type: Boolean, default: false },
    telegramJoin: { type: Boolean, default: false },
    youtubeSubscribe: { type: Boolean, default: false },
    websiteVisit: { type: Boolean, default: false },
    twitterLike: { type: Boolean, default: false },
    twitterMention: { type: Boolean, default: false },
    youtubeLike: { type: Boolean, default: false },
    youtubeComment: { type: Boolean, default: false },
    telegramEngage: { type: Boolean, default: false }
  },
   tonWallet: {
    address: { 
      type: String, 
      default: '',
      unique: true // This ensures no two users can have the same wallet address
    },
    connectedAt: { type: Date, default: null },
    isTelegramWallet: { type: Boolean, default: false }
  },

  streakCount: { type: Number, default: 0 },
  nextCheckInAvailable: Date
});

const User = mongoose.model('User', userSchema);

// Connect to MongoDB
mongoose.connect(process.env.MONGODB_URI)
  .then(() => console.log('âœ… MongoDB connected'))
  .catch(err => console.error('âŒ MongoDB connection failed:', err));



const bot = new Telegraf(process.env.BOT_TOKEN);
app.use(bot.webhookCallback('/webhook'));  // Must come RIGHT HERE



// API Clients
const twitterClient = new TwitterApi({
  appKey: process.env.TWITTER_API_KEY,
  appSecret: process.env.TWITTER_API_SECRET,
  accessToken: process.env.TWITTER_ACCESS_TOKEN,
  accessSecret: process.env.TWITTER_ACCESS_SECRET
});


const youtube = google.youtube({
  version: 'v3',
  auth: process.env.YOUTUBE_API_KEY
});


// VIFA Configuration
const VIFA = {
  links: {
    twitter: 'https://x.com/vifa_global',
    telegram: 'https://t.me/VifaGlobal',
    youtube: 'https://www.youtube.com/@VIFAGlobal',
    website: 'https://vi-fa.co/'
  },
  channelId: process.env.YOUTUBE_CHANNEL_ID,
  telegramGroupId: process.env.TELEGRAM_GROUP_ID,
  latestTweetId: '1901339044547830113', // Replace with actual tweet ID
  latestVideoId: 'watch?v=huagG5RimpE&t=8s' // Replace with actual YouTube video ID
};


// Admin user ID
const ADMIN_USER_ID = 'vifa_global'; // Replace with actual admin Telegram user ID


// ======================
// GIVEAWAY SYSTEM (FIXED)
// ======================

const activeGiveaways = new Map(); // { giveawayId: { prize, participants, messageId, chatId } }
const VIFA_CHANNEL_ID = -1002554670253; // Your channel ID



// 1. ADMIN COMMAND TO START GIVEAWAY
bot.command('giveaway_start', async (ctx) => {
  if (!isAdmin(ctx.from.id)) return ctx.reply('âŒ Admin only');
  
  const points = parseInt(ctx.message.text.split(' ')[1]);
  if (!points || isNaN(points)) return ctx.reply('âš ï¸ Usage: /giveaway_start <amount>');

  try {
    // Create unique giveaway ID
    const giveawayId = Date.now().toString(36);
    
    // Post to channel
    const msg = await ctx.telegram.sendMessage(
      VIFA_CHANNEL_ID,
      `ğŸ‰ <b>VIFA GIVEAWAY</b> ğŸ‰\n\n` +
      `ğŸ’° Prize: <b>${points} VP</b>\n\n` +
      `Click JOIN to participate!\n\n` +
      `#VifaGlobal #Giveaway`,
      {
        parse_mode: 'HTML',
        reply_markup: {
          inline_keyboard: [[
            { 
              text: 'ğŸŸï¸ JOIN GIVEAWAY', 
              callback_data: `giveaway_join:${giveawayId}` 
            }
          ]]
        }
      }
    );

    // Store giveaway
    activeGiveaways.set(giveawayId, {
      messageId: msg.message_id,
      prize: points,
      participants: [],
      chatId: msg.chat.id
    });

    ctx.reply(`âœ… Giveaway started in @VifaGlobal! Prize: ${points} VP`);

  } catch (err) {
    console.error('Giveaway start error:', err);
    ctx.reply('âŒ Failed to post to channel. Check bot permissions.');
  }
});

// 2. BUTTON CLICK HANDLER (FIXED FOR MULTIPLE JOINS)
bot.action(/giveaway_join:(.+)/, async (ctx) => {
  try {
    const giveawayId = ctx.match[1];
    const giveaway = activeGiveaways.get(giveawayId);
    
    if (!giveaway) {
      return ctx.answerCbQuery('âŒ Giveaway not found or ended', { show_alert: true });
    }

    // Check if user exists
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) {
      return ctx.answerCbQuery('âš ï¸ Please /start the bot first', { show_alert: true });
    }

    // Check if user already joined
    if (giveaway.participants.includes(ctx.from.id)) {
      return ctx.answerCbQuery('âœ… You already joined this giveaway!');
    }

    // Add participant
    giveaway.participants.push(ctx.from.id);
    activeGiveaways.set(giveawayId, giveaway);

    // Update button to show participant count
    await ctx.telegram.editMessageReplyMarkup(
      giveaway.chatId,
      giveaway.messageId,
      undefined,
      {
        inline_keyboard: [[
          { 
            text: `ğŸŸï¸ JOIN (${giveaway.participants.length})`, 
            callback_data: `giveaway_join:${giveawayId}`
          }
        ]]
      }
    );

    ctx.answerCbQuery('ğŸ‰ You entered the giveaway! Good luck!');

  } catch (err) {
    console.error('Join error:', err);
    ctx.answerCbQuery('âŒ Failed to join. Try again.');
  }
});

// 3. ADMIN COMMAND TO END GIVEAWAY
bot.command('giveaway_end', async (ctx) => {
  if (!isAdmin(ctx.from.id)) return ctx.reply('âŒ Admin only');
  
  const [giveawayId, giveaway] = [...activeGiveaways.entries()][0] || [];
  if (!giveaway) return ctx.reply('âŒ No active giveaways');

  try {
    if (giveaway.participants.length === 0) {
      activeGiveaways.delete(giveawayId);
      return ctx.reply('âŒ No participants in this giveaway');
    }

    // Pick random winner
    const winnerId = giveaway.participants[Math.floor(Math.random() * giveaway.participants.length)];
    
    // Award points
    await User.updateOne(
      { userId: winnerId },
      { $inc: { points: giveaway.prize } }
    );

    // Get winner info
    let winnerInfo = `ID: ${winnerId}`;
    try {
      const user = await ctx.telegram.getChat(winnerId);
      winnerInfo = user.username ? `@${user.username}` : user.first_name;
    } catch (e) {
      console.log('Could not fetch user info:', e);
    }

    // Announce winner
    await ctx.telegram.sendMessage(
      VIFA_CHANNEL_ID,
      `ğŸ† <b>GIVEAWAY WINNER</b> ğŸ†\n\n` +
      `ğŸ’° Prize: ${giveaway.prize} VP\n` +
      `ğŸ‘¤ Winner: <b>${winnerInfo}</b>\n` +
      `ğŸ‰ Congratulations! ğŸ‰\n\n` +
      `Total participants: ${giveaway.participants.length}`,
      { parse_mode: 'HTML' }
    );

    // Cleanup
    activeGiveaways.delete(giveawayId);
    ctx.reply(`âœ… Giveaway ended! Winner: ${winnerInfo}`);

  } catch (err) {
    console.error('End error:', err);
    ctx.reply('âŒ Failed to end giveaway');
  }
});


// ======================
// CORE FUNCTIONALITY
// ======================
// Enhanced Start Command with Links
bot.command('start', async (ctx) => {
  try {
    // Backend processing (silent)
    await User.findOneAndUpdate(
      { userId: ctx.from.id },
      { $setOnInsert: { points: 0 } },
      { upsert: true, new: true }
    );
const username = ctx.from.username || `user_${ctx.from.id}`;
  
  await User.findOneAndUpdate(
    { userId: ctx.from.id },
    { 
      $setOnInsert: { 
        points: 0,
        username: username 
      } 
    },
    { upsert: true }
  );
    
    // Check for referral
    const refId = ctx.message.text.split(' ')[1]?.replace('ref_', '');
    if (refId && refId !== ctx.from.id.toString()) {
      await User.updateOne(
        { userId: refId },
        { $inc: { points: 10 } }
      );
    }

    // Send links to user with emojis
    await ctx.replyWithMarkdown(`
ğŸŒŸ *Welcome to VIFA!* ğŸŒŸ

Here are our official links:

ğŸ“¢ *Official Channel*: [VIFA Global](t.me/VifaGlobal)
ğŸ¤– *VIFA App*: [Get Started](https://t.me/VIFACoinBot/VIFACoin)
ğŸŒ *All Links*: [LinkTree](https://linktr.ee/vifa.global)

Happy exploring! ğŸš€
    `, {
      disable_web_page_preview: false
    });

  } catch (err) {
    console.error('Start error:', err);
    await ctx.reply('âš ï¸ An error occurred. Please try again later.');
  }
});



// ======================
// CHECK-IN SYSTEM (Every 24 hours)
// ======================

// Update the user schema to include check-in tracking (no changes needed from previous version)

// Check-in command (updated for 24-hour cooldown)
bot.command('checkin', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');






    const now = new Date();
    const cooldownHours = 24; // Changed from 8 to 24 hours between check-ins
    const bonusDays = [3, 7, 14, 30]; // Days that get streak bonuses
    const basePoints = 20; // Base points per check-in
    const streakBonus = 25; // Bonus points for 7-day streak






    // Check if user can check in again
    if (user.nextCheckInAvailable && now < user.nextCheckInAvailable) {
      const nextCheckIn = new Date(user.nextCheckInAvailable);
      const hoursLeft = Math.ceil((nextCheckIn - now) / (1000 * 60 * 60));
      return ctx.reply(`â³ You can check in again in ${hoursLeft} hours!`);
    }






    // Calculate if this is a streak continuation
    let isStreakContinued = false;
    if (user.lastCheckIn) {
      const lastCheckInDate = new Date(user.lastCheckIn);
      const lastCheckInDay = new Date(lastCheckInDate);
      lastCheckInDay.setHours(0, 0, 0, 0);
     
      const today = new Date(now);
      today.setHours(0, 0, 0, 0);
     
      // Reset streak if more than 1 day has passed since last daily check-in
      if ((today - lastCheckInDay) > (1 * 24 * 60 * 60 * 1000)) {
        await User.updateOne(
          { userId: ctx.from.id },
          { streakCount: 0 }
        );
      }
      // Check if this is the first check-in of a new day (for streak purposes)
      else if (today > lastCheckInDay) {
        isStreakContinued = true;
      }
    }






    // Calculate points and streak
    let pointsEarned = basePoints;
    let streakMessage = '';
    let bonusMessage = '';
   
    // Update streak count (only increments once per calendar day)
    let newStreakCount = user.streakCount;
    if (isStreakContinued) {
      newStreakCount += 1;
    } else if (!user.lastCheckIn) {
      // First check-in ever
      newStreakCount = 1;
    }
   
    // Check for streak bonus (once per day when streak increases)
    if (isStreakContinued && newStreakCount === 7) {
      pointsEarned += streakBonus;
      bonusMessage = `ğŸŠ BONUS! +${streakBonus} VP for 7-day streak!\n`;
    }






    // Update user record
    const nextCheckInTime = new Date(now);
    nextCheckInTime.setHours(now.getHours() + cooldownHours);
   
    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: pointsEarned },
        $set: {
          lastCheckIn: now,
          streakCount: newStreakCount,
          nextCheckInAvailable: nextCheckInTime
        }
      }
    );






    // Format next check-in time (e.g., 6:30 PM format)
    const nextCheckInFormatted = new Date(nextCheckInTime);
    const hours = nextCheckInFormatted.getHours();
    const minutes = nextCheckInFormatted.getMinutes();
    const ampm = hours >= 12 ? 'PM' : 'AM';
    const displayHours = hours % 12 || 12;
    const displayMinutes = minutes.toString().padStart(2, '0');
    const nextCheckInTimeStr = `${displayHours}:${displayMinutes} ${ampm}`;






    // Send success message
    await ctx.replyWithHTML(
      `âœ… <b>Check-in successful!</b>\n\n` +
      `ğŸ’° Earned: +${basePoints} VP\n` +
      `${bonusMessage}` +
      `ğŸ”¥ Streak: ${newStreakCount} days\n` +
      `â³ Next check-in: ${nextCheckInTimeStr}`
    );






  } catch (err) {
    console.error('Check-in error:', err);
    ctx.reply('âŒ Failed to process check-in. Please try again.');
  }
});


// Update the tasks command to show next check-in time
bot.command('tasks', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');

    const now = new Date();
    let checkInStatus = 'ğŸ”¹';
    let nextCheckInMessage = '';
   
    if (user.nextCheckInAvailable && now < user.nextCheckInAvailable) {
      const nextCheckIn = new Date(user.nextCheckInAvailable);
      const hoursLeft = Math.ceil((nextCheckIn - now) / (1000 * 60 * 60));
      nextCheckInMessage = ` (next in ${hoursLeft}h)`;
    } else {
      checkInStatus = 'ğŸŸ¢'; // Green circle when available
    }

    await ctx.replyWithHTML(
      `ğŸ“‹ <b>Available Tasks</b>\n\n` +
      `ğŸ”¹ <u>Daily Check-in</u> (Every 24 hours):\n` +
      `${checkInStatus} /checkin - Earn 20 VP${nextCheckInMessage}\n` +
      `ğŸ”¥ Current streak: ${user.streakCount} days\n` +
      `${user.streakCount >= 6 ? 'â­ Next streak bonus at 7 days!' : ''}\n\n` +
     
      `ğŸ”¹ <u>Follow Tasks</u>:\n` +
      `${user.completedTasks.twitterFollow ? 'âœ…' : 'ğŸ”¹'} /follow_twitter - Follow Twitter (15 VP)\n` +
      `${user.completedTasks.telegramJoin ? 'âœ…' : 'ğŸ”¹'} /join_telegram - Join Telegram (15 VP)\n` +
      `${user.completedTasks.youtubeSubscribe ? 'âœ…' : 'ğŸ”¹'} /subscribe_yt - Subscribe YouTube (15 VP)\n` +
      `${user.completedTasks.websiteVisit ? 'âœ…' : 'ğŸ”¹'} /visit_website - Visit website (15 VP)\n\n` +
     
      `ğŸ”¹ <u>Twitter Engagement</u>:\n` +
      `${user.completedTasks.twitterLike ? 'âœ…' : 'ğŸ”¹'} /like_tweet - Like our tweet (5 VP)\n` +
      `${user.completedTasks.twitterMention ? 'âœ…' : 'ğŸ”¹'} /mention_task - Mention 3 friends (10 VP)\n\n` +
     
      `ğŸ”¹ <u>YouTube Engagement</u>:\n` +
      `${user.completedTasks.youtubeLike ? 'âœ…' : 'ğŸ”¹'} /like_video - Like our video (5 VP)\n` +
      `${user.completedTasks.youtubeComment ? 'âœ…' : 'ğŸ”¹'} /comment_video - Comment on video (10 VP)\n\n` +
     
      `ğŸ”¹ <u>Telegram Engagement</u>:\n` +
      `${user.completedTasks.telegramEngage ? 'âœ…' : 'ğŸ”¹'} /engage_telegram - Like & share posts (10 VP)\n\n` +
     
      `ğŸ’° Your balance: <b>${user.points} VP</b>\n` +
      `ğŸ“¨ /invite - Earn referral VP`
    );
  } catch (err) {
    console.error('Tasks error:', err);
    ctx.reply('âŒ Failed to load tasks. Try again.');
  }
});


// ======================
// FOLLOW TASKS
// ======================


// Follow Twitter Task
bot.command('follow_twitter', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.twitterFollow) return ctx.reply('âœ… You already completed this task');




    await ctx.replyWithHTML(
      `ğŸ¦ <b>Follow Twitter Task (15 VP)</b>\n\n` +
      `1. Follow our Twitter: <a href="${VIFA.links.twitter}">@vifa_global</a>\n` +
      `2. Reply with your Twitter username:\n` +
      `<code>/verify_twitter_follow your_twitter_handle</code>\n\n` +
      `Example: <code>/verify_twitter_follow john_doe</code>`
    );
  } catch (err) {
    console.error('Twitter follow task error:', err);
    ctx.reply('âŒ System error. Try again.');
  }
});




bot.command('verify_twitter_follow', async (ctx) => {
  try {
    const [_, twitterHandle] = ctx.message.text.split(' ');
    if (!twitterHandle) return ctx.reply('âš ï¸ Please provide your Twitter handle');




    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.twitterFollow) return ctx.reply('âœ… Already completed');




    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: 15 },
        $set: {
          'completedTasks.twitterFollow': true,
          'twitterHandle': twitterHandle
        }
      }
    );
    ctx.replyWithHTML(`âœ… <b>Twitter follow recorded!</b> +15 VP\nğŸ’° Total: <b>${user.points + 15}</b>`);
  } catch (err) {
    console.error('Twitter follow verify error:', err);
    ctx.reply('âŒ Verification failed. Try again later.');
  }
});




// Join Telegram Task
bot.command('join_telegram', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.telegramJoin) return ctx.reply('âœ… You already completed this task');




    await ctx.replyWithHTML(
      `ğŸ“¢ <b>Join Telegram Task (15 VP)</b>\n\n` +
      `1. Join our Telegram channel: <a href="${VIFA.links.telegram}">VIFA Global</a>\n` +
      `2. Click this button to verify: /verify_telegram_join`
    );
  } catch (err) {
    console.error('Telegram join task error:', err);
    ctx.reply('âŒ System error. Try again.');
  }
});




bot.command('verify_telegram_join', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.telegramJoin) return ctx.reply('âœ… Already completed');




    // Check if user joined the channel
    try {
      const member = await ctx.telegram.getChatMember(-1002554670253, ctx.from.id);
      if (member.status === 'left') {
        return ctx.reply('âŒ You must join our channel first: ' + VIFA.links.telegram);
      }
    } catch (err) {
      console.error('Channel check error:', err);
      return ctx.reply('âŒ Could not verify channel membership. Please try again.');
    }




    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: 15 },
        $set: { 'completedTasks.telegramJoin': true }
      }
    );
    ctx.replyWithHTML(`âœ… <b>Telegram join recorded!</b> +15 VP\nğŸ’° Total: <b>${user.points + 15}</b>`);
  } catch (err) {
    console.error('Telegram join verify error:', err);
    ctx.reply('âŒ Verification failed. Try again later.');
  }
});




// Subscribe YouTube Task
bot.command('subscribe_yt', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.youtubeSubscribe) return ctx.reply('âœ… You already completed this task');




    await ctx.replyWithHTML(
      `â–¶ï¸ <b>Subscribe YouTube Task (15 VP)</b>\n\n` +
      `1. Subscribe to our YouTube channel: <a href="${VIFA.links.youtube}">VIFA Global</a>\n` +
      `2. Click this button to verify: /verify_youtube_subscribe`
    );
  } catch (err) {
    console.error('YouTube subscribe task error:', err);
    ctx.reply('âŒ System error. Try again.');
  }
});




bot.command('verify_youtube_subscribe', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.youtubeSubscribe) return ctx.reply('âœ… Already completed');




    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: 15 },
        $set: { 'completedTasks.youtubeSubscribe': true }
      }
    );
    ctx.replyWithHTML(`âœ… <b>YouTube subscription recorded!</b> +15 VP\nğŸ’° Total: <b>${user.points + 15}</b>`);
  } catch (err) {
    console.error('YouTube subscribe verify error:', err);
    ctx.reply('âŒ Verification failed. Try again later.');
  }
});




// Visit Website Task
bot.command('visit_website', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.websiteVisit) return ctx.reply('âœ… You already completed this task');




    await ctx.replyWithHTML(
      `ğŸŒ <b>Visit Website Task (15 VP)</b>\n\n` +
      `1. Visit our website: <a href="${VIFA.links.website}">vi-fa.co</a>\n` +
      `2. Click this button after visiting: /verify_website_visit`
    );
  } catch (err) {
    console.error('Website visit task error:', err);
    ctx.reply('âŒ System error. Try again.');
  }
});




bot.command('verify_website_visit', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.websiteVisit) return ctx.reply('âœ… Already completed');




    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: 15 },
        $set: { 'completedTasks.websiteVisit': true }
      }
    );
    ctx.replyWithHTML(`âœ… <b>Website visit recorded!</b> +15 VP\nğŸ’° Total: <b>${user.points + 15}</b>`);
  } catch (err) {
    console.error('Website visit verify error:', err);
    ctx.reply('âŒ Verification failed. Try again later.');
  }
});




// ======================
// TWITTER ENGAGEMENT TASKS
// ======================

// Like Tweet Task
bot.command('like_tweet', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.twitterLike) return ctx.reply('âœ… You already completed this task');
    if (!user.twitterHandle) return ctx.reply('âŒ Please complete /follow_twitter first');




    await ctx.replyWithHTML(
      `â¤ï¸ <b>Like Tweet Task (5 VP)</b>\n\n` +
      `1. Like our latest tweet:\n` +
      `<a href="${VIFA.links.twitter}/status/${VIFA.latestTweetId}">VIFA Global Tweet</a>\n` +
      `2. Click this button to verify: /verify_twitter_like`
    );
  } catch (err) {
    console.error('Twitter like task error:', err);
    ctx.reply('âŒ System error. Try again.');
  }
});




bot.command('verify_twitter_like', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.twitterLike) return ctx.reply('âœ… Already completed');
    if (!user.twitterHandle) return ctx.reply('âŒ Please complete /follow_twitter first');




    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: 5 },
        $set: { 'completedTasks.twitterLike': true }
      }
    );
    ctx.replyWithHTML(`âœ… <b>Tweet like recorded!</b> +5 VP\nğŸ’° Total: <b>${user.points + 5}</b>`);
  } catch (err) {
    console.error('Twitter like verify error:', err);
    ctx.reply('âŒ Verification failed. Try again later.');
  }
});




// Mention Friends Task
bot.command('mention_task', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.twitterMention) return ctx.reply('âœ… You already completed this task');
    if (!user.twitterHandle) return ctx.reply('âŒ Please complete /follow_twitter first');




    await ctx.replyWithHTML(
      `ğŸ‘¥ <b>Mention Friends Task (10 VP)</b>\n\n` +
      `1. Reply to our tweet mentioning 3 friends:\n` +
      `<a href="${VIFA.links.twitter}/status/${VIFA.latestTweetId}">VIFA Global Tweet</a>\n` +
      `2. Reply with the tweet URL:\n` +
      `<code>/verify_mention tweet_url</code>\n\n` +
      `Example: <code>/verify_mention https://x.com/vifa_global/status/123456789</code>`
    );
  } catch (err) {
    console.error('Twitter mention task error:', err);
    ctx.reply('âŒ System error. Try again.');
  }
});




bot.command('verify_mention', async (ctx) => {
  try {
    const [_, tweetUrl] = ctx.message.text.split(' ');
    if (!tweetUrl) return ctx.reply('âš ï¸ Please provide the tweet URL');




    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.twitterMention) return ctx.reply('âœ… Already completed');
    if (!user.twitterHandle) return ctx.reply('âŒ Please complete /follow_twitter first');




    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: 10 },
        $set: { 'completedTasks.twitterMention': true }
      }
    );
    ctx.replyWithHTML(`âœ… <b>Mention recorded!</b> +10 VP\nğŸ’° Total: <b>${user.points + 10}</b>`);
  } catch (err) {
    console.error('Twitter mention verify error:', err);
    ctx.reply('âŒ Verification failed. Try again later.');
  }
});




// ======================
// YOUTUBE ENGAGEMENT TASKS
// ======================

// YouTube Like Task
bot.command('like_video', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.youtubeLike) return ctx.reply('âœ… You already completed this task');
    if (!user.completedTasks.youtubeSubscribe) return ctx.reply('âŒ Please complete /subscribe_yt first');

    await ctx.replyWithHTML(
      `ğŸ‘ <b>YouTube Like Task (5 VP)</b>\n\n` +
      `1. Like our latest video:\n` +
      `<a href="${VIFA.links.youtube}/watch?v=${VIFA.latestVideoId}">VIFA Global Video</a>\n` +
      `2. Click this button to verify: /verify_youtube_like`
    );
  } catch (err) {
    console.error('YouTube like task error:', err);
    ctx.reply('âŒ System error. Try again.');
  }
});


bot.command('verify_youtube_like', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.youtubeLike) return ctx.reply('âœ… Already completed');
    if (!user.completedTasks.youtubeSubscribe) return ctx.reply('âŒ Please complete /subscribe_yt first');




    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: 5 },
        $set: { 'completedTasks.youtubeLike': true }
      }
    );
    ctx.replyWithHTML(`âœ… <b>Video like recorded!</b> +5 VP\nğŸ’° Total: <b>${user.points + 5}</b>`);
  } catch (err) {
    console.error('YouTube like verify error:', err);
    ctx.reply('âŒ Verification failed. Try again later.');
  }
});




// YouTube Comment Task
bot.command('comment_video', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.youtubeComment) return ctx.reply('âœ… You already completed this task');
    if (!user.completedTasks.youtubeSubscribe) return ctx.reply('âŒ Please complete /subscribe_yt first');




    await ctx.replyWithHTML(
      `ğŸ’¬ <b>YouTube Comment Task (10 VP)</b>\n\n` +
      `1. Comment on our video:\n` +
      `<a href="${VIFA.links.youtube}/watch?v=${VIFA.latestVideoId}">VIFA Global Video</a>\n` +
      `2. Reply with your comment text:\n` +
      `<code>/verify_youtube_comment "Your comment text"</code>`
    );
  } catch (err) {
    console.error('YouTube comment task error:', err);
    ctx.reply('âŒ System error. Try again.');
  }
});




bot.command('verify_youtube_comment', async (ctx) => {
  try {
    const [_, ...commentParts] = ctx.message.text.split(' ');
    const commentText = commentParts.join(' ').replace(/"/g, '');
   
    if (!commentText) {
      return ctx.reply('âš ï¸ Please provide your comment text');
    }




    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.youtubeComment) return ctx.reply('âœ… Already completed');
    if (!user.completedTasks.youtubeSubscribe) return ctx.reply('âŒ Please complete /subscribe_yt first');




    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: 10 },
        $set: { 'completedTasks.youtubeComment': true }
      }
    );
    ctx.replyWithHTML(`âœ… <b>Comment recorded!</b> +10 VP\nğŸ’° Total: <b>${user.points + 10}</b>`);
  } catch (err) {
    console.error('YouTube comment verify error:', err);
    ctx.reply('âŒ Verification failed. Try again later.');
  }
});




// ======================
// TELEGRAM ENGAGEMENT TASKS
// ======================


// Telegram Engagement Task
bot.command('engage_telegram', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.telegramEngage) return ctx.reply('âœ… You already completed this task');
    if (!user.completedTasks.telegramJoin) return ctx.reply('âŒ Please complete /join_telegram first');




    await ctx.replyWithHTML(
      `ğŸ”¹ <b>Telegram Engagement Task (10 VP)</b>\n\n` +
      `1. Like and share our latest post in:\n` +
      `<a href="${VIFA.links.telegram}">VIFA Telegram Channel</a>\n` +
      `2. Click this button to verify: /verify_telegram_engage`
    );
  } catch (err) {
    console.error('Telegram engage task error:', err);
    ctx.reply('âŒ System error. Try again.');
  }
});




bot.command('verify_telegram_engage', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');
    if (user.completedTasks.telegramEngage) return ctx.reply('âœ… Already completed');
    if (!user.completedTasks.telegramJoin) return ctx.reply('âŒ Please complete /join_telegram first');




    // Check if user joined the channel
    try {
      const member = await ctx.telegram.getChatMember(-1002554670253, ctx.from.id);
      if (member.status === 'left') {
        return ctx.reply('âŒ You must join our channel first: ' + VIFA.links.telegram);
      }
    } catch (err) {
      console.error('Channel check error:', err);
      return ctx.reply('âŒ Could not verify channel membership. Please try again.');
    }




    await User.updateOne(
      { userId: ctx.from.id },
      {
        $inc: { points: 5 },
        $set: { 'completedTasks.telegramEngage': true }
      }
    );
    ctx.replyWithHTML(`âœ… <b>Engagement recorded!</b> +10 VP\nğŸ’° Total: <b>${user.points + 10}</b>`);
  } catch (err) {
    console.error('Telegram engage verify error:', err);
    ctx.reply('âŒ Verification failed. Try again later.');
  }
});


// ======================
// TASKS MENU
// ======================


bot.command('tasks', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');

    await ctx.replyWithHTML(
      `ğŸ“‹ <b>Available Tasks</b>\n\n` +

      
      `ğŸ”¹ <u>Follow Tasks</u>:\n` +
      `${user.completedTasks.twitterFollow ? 'âœ…' : 'ğŸ”¹'} /follow_twitter - Follow Twitter (15 VP)\n` +
      `${user.completedTasks.telegramJoin ? 'âœ…' : 'ğŸ”¹'} /join_telegram - Join Telegram (15 VP)\n` +
      `${user.completedTasks.youtubeSubscribe ? 'âœ…' : 'ğŸ”¹'} /subscribe_yt - Subscribe YouTube (15 VP)\n` +
      `${user.completedTasks.websiteVisit ? 'âœ…' : 'ğŸ”¹'} /visit_website - Visit website (15 VP)\n\n` +
     
      `ğŸ”¹ <u>Twitter Engagement</u>:\n` +
      `${user.completedTasks.twitterLike ? 'âœ…' : 'ğŸ”¹'} /like_tweet - Like our tweet (5 VP)\n` +
      `${user.completedTasks.twitterMention ? 'âœ…' : 'ğŸ”¹'} /mention_task - Mention 3 friends (10 VP)\n\n` +
     
      `ğŸ”¹ <u>YouTube Engagement</u>:\n` +
      `${user.completedTasks.youtubeLike ? 'âœ…' : 'ğŸ”¹'} /like_video - Like our video (5 VP)\n` +
      `${user.completedTasks.youtubeComment ? 'âœ…' : 'ğŸ”¹'} /comment_video - Comment on video (10 VP)\n\n` +
     
      `ğŸ”¹ <u>Telegram Engagement</u>:\n` +
      `${user.completedTasks.telegramEngage ? 'âœ…' : 'ğŸ”¹'} /engage_telegram - Like & share posts (10 VP)\n\n` +
     
      `ğŸ’° Your balance: <b>${user.points} PV</b>\n` +
      `ğŸ“¨ /invite - Earn referral VP`
    );
  } catch (err) {
    console.error('Tasks error:', err);
    ctx.reply('âŒ Failed to load tasks. Try again.');
  } 
});



// ======================
// ADMIN COMMANDS
// ======================

// Admin command to check user points
bot.command('admin_points', async (ctx) => {
  try {
    if (ctx.from.username !== ADMIN_USER_ID) {
      return ctx.reply('âŒ Admin-only command.');
    }




    const [_, userId] = ctx.message.text.split(' ');
    if (!userId) return ctx.reply('âš ï¸ Usage: /admin_points <user_id>');




    const user = await User.findOne({ userId: parseInt(userId) });
    if (!user) return ctx.reply('âŒ User not found');




    await ctx.replyWithHTML(
      `ğŸ‘¤ <b>User VP Report</b>\n\n` +
      `ğŸ†” User ID: <code>${user.userId}</code>\n` +
      `ğŸ’° VP: <b>${user.points}</b>\n` +
      `ğŸ“… Last active: ${user.lastCommand.toLocaleString()}\n\n` +
      `ğŸ”¹ Twitter: ${user.completedTasks.twitterFollow ? 'âœ…' : 'âŒ'}\n` +
      `ğŸ”¹ Telegram: ${user.completedTasks.telegramJoin ? 'âœ…' : 'âŒ'}\n` +
      `ğŸ”¹ YouTube: ${user.completedTasks.youtubeSubscribe ? 'âœ…' : 'âŒ'}\n` +
      `ğŸ”¹ Website: ${user.completedTasks.websiteVisit ? 'âœ…' : 'âŒ'}`
    );
  } catch (err) {
    console.error('Admin VP error:', err);
    ctx.reply('âŒ Failed to fetch user data');
  }
});

// Admin command to add points (REFERAL)
bot.command('invite', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');


    const refLink = `https://t.me/VIFACoinBot?start=ref_${ctx.from.id}`; // Update to direct users to the bot


    await ctx.replyWithHTML(
      `ğŸ“¢ <b>Your Referral Link</b>\n\n` +
      `Earn <b>50 VIFA Points</b> for each friend who joins!\n\n` +
      `<code>${refLink}</code>\n\n` +
      `ğŸ”— Share via: ` +
      `<a href="https://t.me/share/url?url=${encodeURIComponent(refLink)}&text=Join%20VifaGlobal%20for%20exclusive%20rewards!">Telegram</a>`
    );
  } catch (err) {
    console.error('Invite error:', err);
    ctx.reply('âŒ Failed to generate invite link');
  }
});



// ======================
// USER ID 
// ======================
bot.command('id', (ctx) => {
  ctx.replyWithHTML(`ğŸ†” Your Telegram ID: <code>${ctx.from.id}</code>`);
});

// ======================
// REFERRAL TRACKING (BOT STARTS)
// ======================
bot.on('callback_query', async (ctx) => {
  try {
    // 1. Check if the user started the bot via an invite link (referral)
    if (ctx.callbackQuery.data && ctx.callbackQuery.data.startsWith('ref_')) {
      const refId = ctx.callbackQuery.data.replace('ref_', ''); // Extract the referrer ID


      // 2. Set the first referrer as @vifa_global (ID: 8183350482)
      const firstReferrerId = "8183350482";


      // 3. If the user hasn't started the bot yet, assign a referrer
      const user = await User.findOne({ userId: ctx.from.id });
      if (!user) {
        const referrer = refId ? refId : firstReferrerId; // Use the passed referrer or the default @vifa_global


        // Create the new user with the assigned referrer
        await User.create({ userId: ctx.from.id, referrerId: referrer, points: 0 });


        // Assign points to the referrer (first-level referral gets 50 points)
        const pointsForReferral = 50;
        await User.updateOne(
          { userId: referrer },
          { $inc: { points: pointsForReferral } }
        );


        // Notify referrer about the new referral
        await ctx.telegram.sendMessage(
          referrer,
          `ğŸ‰ You earned ${pointsForReferral} VIFA Points! @${ctx.from.username} joined via your referral link.`
        );


        // Optionally notify the new user
        await ctx.reply('ğŸ‰ Welcome to VIFA! You have successfully joined and earned your first VP!');
      }
    }
  } catch (err) {
    console.error('Referral tracking error:', err);
  }
});




// Helper function to check admin status
function isAdmin(userId) {
  return ADMIN_IDS.includes(userId);
}

// Admin command to check user points by user ID
bot.command('admin_points', async (ctx) => {
  try {
    if (!isAdmin(ctx.from.id)) {
      return ctx.reply('âŒ Admin-only command.');
    }

    const [_, userId] = ctx.message.text.split(' ');
    if (!userId) return ctx.reply('âš ï¸ Usage: /admin_points <user_id>');

    const user = await User.findOne({ userId: parseInt(userId) });
    if (!user) return ctx.reply('âŒ User not found');

    await ctx.replyWithHTML(
      `ğŸ‘¤ <b>User VP Report</b>\n\n` +
      `ğŸ†” User ID: <code>${user.userId}</code>\n` +
      `ğŸ’° VP: <b>${user.points}</b>\n` +
      `ğŸ“… Last active: ${user.lastCommand.toLocaleString()}\n\n` +
      `ğŸ”¹ Twitter: ${user.completedTasks.twitterFollow ? 'âœ…' : 'âŒ'}\n` +
      `ğŸ”¹ Telegram: ${user.completedTasks.telegramJoin ? 'âœ…' : 'âŒ'}\n` +
      `ğŸ”¹ YouTube: ${user.completedTasks.youtubeSubscribe ? 'âœ…' : 'âŒ'}\n` +
      `ğŸ”¹ Website: ${user.completedTasks.websiteVisit ? 'âœ…' : 'âŒ'}`
    );
  } catch (err) {
    console.error('Admin VP error:', err);
    ctx.reply('âŒ Failed to fetch user data');
  }
});

// Admin command to reset user by user ID
bot.command('admin_reset', async (ctx) => {
  try {
    if (!isAdmin(ctx.from.id)) {
      return ctx.reply('âŒ Admin-only command.');
    }

    const [_, userId] = ctx.message.text.split(' ');
    if (!userId) return ctx.reply('âš ï¸ Usage: /admin_reset <user_id>');

    const user = await User.findOneAndUpdate(
      { userId: parseInt(userId) },
      {
        points: 0,
        completedTasks: {
          twitterFollow: false,
          telegramJoin: false,
          youtubeSubscribe: false,
          websiteVisit: false,
          twitterLike: false,
          twitterMention: false,
          youtubeLike: false,
          youtubeComment: false,
          telegramEngage: false
        }
      },
      { new: true }
    );

    if (!user) return ctx.reply('âŒ User not found');

    await ctx.replyWithHTML(
      `âœ… <b>User reset successfully!</b>\n\n` +
      `ğŸ†” User ID: <code>${user.userId}</code>\n` +
      `ğŸ’° VP reset to: <b>0</b>\n` +
      `ğŸ”„ All tasks reset`
    );
  } catch (err) {
    console.error('Admin reset error:', err);
    ctx.reply('âŒ Failed to reset user');
  }
});

// Admin command to adjust points
bot.command('admin_adjust', async (ctx) => {
  try {
    if (!isAdmin(ctx.from.id)) {
      return ctx.reply('âŒ Admin-only command.');
    }

    const [_, userId, amountStr] = ctx.message.text.split(' ');
    if (!userId || !amountStr) {
      return ctx.reply('âš ï¸ Usage: /admin_adjust <user_id> <+/-amount>');
    }

    const amount = parseInt(amountStr);
    const user = await User.findOneAndUpdate(
      { userId: parseInt(userId) },
      { $inc: { points: amount } },
      { new: true }
    );

    if (!user) return ctx.reply('âŒ User not found');

    await ctx.replyWithHTML(
      `âœ… <b>VP adjusted successfully!</b>\n\n` +
      `ğŸ†” User ID: <code>${user.userId}</code>\n` +
      `ğŸ”„ Change: ${amount > 0 ? '+' : ''}${amount}\n` +
      `ğŸ’° New Total: <b>${user.points}</b>`
    );

    // Notify user
    try {
      await ctx.telegram.sendMessage(
        user.userId,
        `ğŸ”” Admin adjusted your VP:\n` +
        `ğŸ“ Change: ${amount > 0 ? '+' : ''}${amount}\n` +
        `ğŸ¦ New Balance: ${user.points}`
      );
    } catch (e) {
      console.log("Couldn't notify user", e);
    }
  } catch (err) {
    console.error('Admin adjust error:', err);
    ctx.reply('âŒ Failed to adjust VP');
  }
});


// Add this command handler anywhere with your other commands
bot.command('points', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first to create your account.');

    await ctx.replyWithHTML(
      `ğŸ’° <b>Your VP Balance</b>\n\n` +
      `ğŸ†” User ID: <code>${user.userId}</code>\n` +
      `ğŸŒŸ VP: <b>${user.points}</b>\n\n` +
      `ğŸ“Š Completed tasks: ${Object.values(user.completedTasks).filter(Boolean).length}/9\n` +
      `ğŸ”¥ Current streak: ${user.streakCount} days\n\n` +
      `ğŸ“Œ Use /tasks to see earning opportunities`
    );
  } catch (err) {
    console.error('VP command error:', err);
    ctx.reply('âŒ Failed to fetch your VP. Please try again.');
  }
});

// ======================
// 1 VP PER CLICK FEATURE
// ======================
bot.command('earn_vp', async (ctx) => {
  try {
    // Add 1 VP to user's balance
    const user = await User.findOneAndUpdate(
      { userId: ctx.from.id },
      { $inc: { points: 1 } },
      { upsert: true, new: true }
    );
    
    // Send success message with simple instruction
    await ctx.replyWithHTML(
      `ğŸ’° <b>+1 VP Added!</b>\n\n` +
      `ğŸª™ Total VP: <b>${user.points}</b>\n\n` +
      `âœ¨ Type /earn_vp again to earn more`
    );
  } catch (err) {
    console.error('VP earning error:', err);
    await ctx.reply('âŒ Error adding VP. Try again later.');
  }
});

// VIFA Token App
bot.command('app', (ctx) => {
  // Send message with "Open App" button
  ctx.reply('ğŸš€ Launch VIFA Rewards Mini App:', {
    reply_markup: {
      inline_keyboard: [[
        { 
          text: 'ğŸ“± Open App', 
          web_app: { url: 'https://vifa-mini-app-frontend.onrender.com' } 
        }
      ]]
    }
  });
});

// ======================
// Admin: List all wallets
// ======================
// Wallet connection command
bot.command('connect', async (ctx) => {
  try {
    const user = await User.findOne({ userId: ctx.from.id });
    if (!user) return ctx.reply('âš ï¸ Please /start first');

    if (user.tonWallet?.address) {
      return ctx.replyWithHTML(`âœ… Your wallet is already connected:\n<code>${user.tonWallet.address}</code>\n\nUse /disconnect to remove it`);
    }

    await ctx.replyWithHTML(
      `ğŸ”— <b>Connect Your TON Wallet</b>\n\n` +
      `1. Open @wallet bot\n` +
      `2. Click "Copy Wallet Address"\n` +
      `3. Paste it here like this:\n` +
      `<code>/save_wallet YOUR_WALLET_ADDRESS</code>\n\n` +
      `Example: <code>/save_wallet EQABCD12345...</code>`
    );
  } catch (err) {
    console.error('Wallet connect error:', err);
    ctx.reply('âŒ Failed to process wallet connection. Please try again.');
  }
});

// Save wallet command
bot.command('save_wallet', async (ctx) => {
  try {
    const walletAddress = ctx.message.text.split(' ')[1];
    if (!walletAddress) return ctx.reply('âš ï¸ Please provide your wallet address');

    // Basic TON address validation
    const tonRegex = /^(EQ|UQ)[a-zA-Z0-9_-]{43,}$/;
    if (!tonRegex.test(walletAddress)) {
      return ctx.reply('âŒ Invalid TON wallet address format. Please check and try again.');
    }

    // Check if wallet is already in use by another user
    const existingUser = await User.findOne({ 
      'tonWallet.address': walletAddress,
      userId: { $ne: ctx.from.id } // Exclude current user
    });
    
    if (existingUser) {
      return ctx.reply('âŒ This wallet is already connected to another account.');
    }

    await User.updateOne(
      { userId: ctx.from.id },
      { 
        $set: { 
          'tonWallet.address': walletAddress,
          'tonWallet.connectedAt': new Date(),
          'tonWallet.isTelegramWallet': true
        } 
      }
    );

    ctx.replyWithHTML(`âœ… <b>Wallet connected successfully!</b>\n\n` +
      `Your address: <code>${walletAddress}</code>\n\n` +
      `You can now receive rewards directly to this wallet.\n` +
      `Use /disconnect to remove it later.`);

  } catch (err) {
    console.error('Save wallet error:', err);
    if (err.code === 11000) { // MongoDB duplicate key error
      ctx.reply('âŒ This wallet is already connected to another account.');
    } else {
      ctx.reply('âŒ Failed to save wallet. Please try again.');
    }
  }
});

// Disconnect wallet command
bot.command('disconnect', async (ctx) => {
  try {
    const result = await User.updateOne(
      { userId: ctx.from.id },
      { 
        $unset: { 
          'tonWallet': "" 
        } 
      }
    );

    if (result.modifiedCount === 0) {
      return ctx.reply('â„¹ï¸ You don\'t have a connected wallet.');
    }

    ctx.reply('âœ… Wallet disconnected successfully!');

  } catch (err) {
    console.error('Disconnect wallet error:', err);
    ctx.reply('âŒ Failed to disconnect wallet. Please try again.');
  }
});


// ======================
// Web Server for Render (Port Binding)
// ======================

// In your backend routes (add this endpoint)
app.get('/api/referrals/:userId', async (req, res) => {
  try {
    const user = await User.findOne({ userId: req.params.userId });
    if (!user) return res.status(404).json({ error: "User not found" });

    // Get all users who used this user's referral code
    const referrals = await User.find({ referrerId: user.userId.toString() })
      .select('userId username points createdAt')
      .lean();

    // Format the response
    const referralData = referrals.map(ref => ({
      userId: ref.userId,
      username: ref.username || `user_${ref.userId}`,
      level: 1, // Direct referral is level 1
      pointsEarned: 50, // 50 VP for direct referral
      date: ref.createdAt
    }));

    res.json({ referrals: referralData });
  } catch (err) {
    res.status(500).json({ error: "Failed to fetch referrals" });
  }
});

// Health check route (required for Render)
app.get('/', (req, res) => {
  res.status(200).send('Bot is running');
});

// ======================
// NEW API ROUTES FOR FRONTEND
// ======================

// Get user data (for frontend)
app.get('/api/user/:userId', async (req, res) => {
  try {
    const user = await User.findOne({ userId: parseInt(req.params.userId) });
    if (!user) return res.status(404).json({ error: "User not found" });

    res.json({
      points: user.points,
      streak: user.streakCount
    });
  } catch (err) {
    res.status(500).json({ error: "Server error" });
  }
});


// Add this with your other API routes
app.get('/api/user/:userId/wallet-status', async (req, res) => {
    try {
        const user = await User.findOne({ userId: parseInt(req.params.userId) });
        
        if (!user) {
            return res.status(404).json({ error: "User not found" });
        }

        const walletConnected = !!user?.tonWallet?.address;
        
        res.json({
            connected: walletConnected,
            walletAddress: walletConnected ? 
                `${user.tonWallet.address.substring(0, 6)}...${user.tonWallet.address.substring(user.tonWallet.address.length - 4)}` : 
                null,
            isTelegramWallet: user?.tonWallet?.isTelegramWallet || false,
            connectedAt: user?.tonWallet?.connectedAt || null
        });
        
    } catch (err) {
        console.error('Wallet status check error:', err);
        res.status(500).json({ error: "Server error checking wallet status" });
    }
});

// Add points (for button clicks)
app.post('/api/user/:userId/add-points', async (req, res) => {
  try {
    const user = await User.findOneAndUpdate(
      { userId: parseInt(req.params.userId) },
      { $inc: { points: req.body.points || 1 } },
      { new: true }
    );

    if (!user) return res.status(404).json({ error: "User not found" });
    res.json({ points: user.points });
  } catch (err) {
    res.status(500).json({ error: "Failed to update points" });
  }
});

// Add this to your Express routes (before app.listen)
app.post('/earn_vp', async (req, res) => {
    try {
        const { user_id } = req.body;
        
        // Update user points in DB
        await User.findOneAndUpdate(
            { userId: user_id },
            { $inc: { points: 1 } }
        );

        res.json({ success: true, message: "+1 VP added!" });
    } catch (err) {
        res.status(500).json({ success: false, error: err.message });
    }
});

// Add this route handler before app.listen()
app.post('/api/earn_vp', express.json(), async (req, res) => {
  try {
    const { userId } = req.body;
    
    if (!userId) {
      return res.status(400).json({ error: "User ID is required" });
    }

    // Update user points in DB
    const user = await User.findOneAndUpdate(
      { userId: parseInt(userId) },
      { $inc: { points: 1 } },
      { new: true, upsert: true }
    );

    res.json({ 
      success: true, 
      points: user.points,
      message: "+1 VP added successfully!" 
    });
  } catch (err) {
    console.error('Earn VP error:', err);
    res.status(500).json({ 
      success: false, 
      error: "Failed to update points" 
    });
  }
});

// Daily check-in API endpoint
app.post('/api/checkin', express.json(), async (req, res) => {
  try {
    const { userId } = req.body;
    
    if (!userId) {
      return res.status(400).json({ error: "User ID is required" });
    }

    const user = await User.findOne({ userId: parseInt(userId) });
    if (!user) return res.status(404).json({ error: "User not found" });

    const now = new Date();
    const cooldownHours = 24;

    // Check if user can check in again
    if (user.nextCheckInAvailable && now < user.nextCheckInAvailable) {
      const nextCheckIn = new Date(user.nextCheckInAvailable);
      const hoursLeft = Math.ceil((nextCheckIn - now) / (1000 * 60 * 60));
      return res.status(400).json({ 
        error: `You can check in again in ${hoursLeft} hours!`,
        nextCheckIn: user.nextCheckInAvailable
      });
    }

    // Calculate points and streak (same logic as Telegram command)
    let pointsEarned = 20; // Base points
    let isStreakContinued = false;
    let newStreakCount = user.streakCount;

    if (user.lastCheckIn) {
      const lastCheckInDate = new Date(user.lastCheckIn);
      const lastCheckInDay = new Date(lastCheckInDate);
      lastCheckInDay.setHours(0, 0, 0, 0);
     
      const today = new Date(now);
      today.setHours(0, 0, 0, 0);
     
      if ((today - lastCheckInDay) > (1 * 24 * 60 * 60 * 1000)) {
        newStreakCount = 0;
      }
      else if (today > lastCheckInDay) {
        isStreakContinued = true;
        newStreakCount += 1;
      }
    } else {
      newStreakCount = 1;
    }

    // 7-day streak bonus
    if (isStreakContinued && newStreakCount === 7) {
      pointsEarned += 25;
    }

    // Update user record
    const nextCheckInTime = new Date(now);
    nextCheckInTime.setHours(now.getHours() + cooldownHours);
   
    await User.updateOne(
      { userId: parseInt(userId) },
      {
        $inc: { points: pointsEarned },
        $set: {
          lastCheckIn: now,
          streakCount: newStreakCount,
          nextCheckInAvailable: nextCheckInTime
        }
      }
    );

    res.json({ 
      success: true,
      points: user.points + pointsEarned,
      streak: newStreakCount,
      pointsEarned: pointsEarned,
      nextCheckIn: nextCheckInTime,
      message: `Check-in successful! Earned ${pointsEarned} VP`
    });

  } catch (err) {
    console.error('Check-in API error:', err);
    res.status(500).json({ error: "Failed to process check-in" });
  }
});

// Add this to your Express routes
app.get('/api/user/:userId/checkin-status', async (req, res) => {
  try {
    const user = await User.findOne({ userId: parseInt(req.params.userId) });
    if (!user) return res.status(404).json({ error: "User not found" });

    const now = new Date();
    const canCheckIn = !user.nextCheckInAvailable || now >= user.nextCheckInAvailable;
    
    res.json({
      canCheckIn,
      nextCheckIn: user.nextCheckInAvailable,
      streak: user.streakCount
    });
  } catch (err) {
    res.status(500).json({ error: "Server error" });
  }
});

// Task verification endpoints
app.post('/api/verify-twitter-follow', express.json(), async (req, res) => {
  await verifyTaskHandler(req, res, 'twitterFollow', 15);
});

app.post('/api/verify-telegram-join', express.json(), async (req, res) => {
  await verifyTaskHandler(req, res, 'telegramJoin', 15);
});

app.post('/api/verify-youtube-subscribe', express.json(), async (req, res) => {
  await verifyTaskHandler(req, res, 'youtubeSubscribe', 15);
});

app.post('/api/verify-website-visit', express.json(), async (req, res) => {
  await verifyTaskHandler(req, res, 'websiteVisit', 15);
});

app.post('/api/verify-twitter-like', express.json(), async (req, res) => {
  await verifyTaskHandler(req, res, 'twitterLike', 5);
});

app.post('/api/verify-youtube-like', express.json(), async (req, res) => {
  await verifyTaskHandler(req, res, 'youtubeLike', 5);
});

app.post('/api/verify-youtube-comment', express.json(), async (req, res) => {
  await verifyTaskHandler(req, res, 'youtubeComment', 10);
});

app.post('/api/verify-telegram-engage', express.json(), async (req, res) => {
  await verifyTaskHandler(req, res, 'telegramEngage', 10);
});

// Reusable verification handler
async function verifyTaskHandler(req, res, taskName, points) {
  try {
    const { userId, ...verificationData } = req.body;
    
    // First check if task was already completed
    const existingUser = await User.findOne({ 
      userId: parseInt(userId),
      [`completedTasks.${taskName}`]: true 
    });
    
    if (existingUser) {
      return res.status(400).json({ 
        error: "Task already completed" 
      });
    }

    // Use findOneAndUpdate with conditions
    const user = await User.findOneAndUpdate(
      { 
        userId: parseInt(userId),
        [`completedTasks.${taskName}`]: { $ne: true } // Ensure task wasn't completed
      },
      {
        $inc: { points },
        $set: { 
          [`completedTasks.${taskName}`]: true,
          [`completedTasks.${taskName}Timestamp`]: new Date() 
        }
      },
      { new: true }
    );

    if (!user) {
      return res.status(400).json({ 
        error: "User not found or task already completed" 
      });
    }

    res.json({
      success: true,
      points: user.points,
      message: `Task verified! +${points} VP`
    });
  } catch (err) {
    res.status(500).json({ error: "Verification failed" });
  }
}
// After successful wallet connection, send data to backend
async function saveUserData(userId, walletAddress) {
    try {
        const response = await fetch('/api/save-user', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                userId,
                walletAddress
            }),
        });
        return await response.json();
    } catch (error) {
        console.error('Error saving user:', error);
    }
}

// Wallet connection API endpoint
app.post('/api/save-wallet', express.json(), async (req, res) => {
  try {
    // Validate request body structure
    if (!req.body || typeof req.body !== 'object') {
      return res.status(400).json({ error: "Invalid request body" });
    }

    // Destructure with default values
    const { userId, walletAddress: rawAddress } = req.body;
    
    // Validate required fields
    if (!userId || !rawAddress) {
      return res.status(400).json({ 
        error: "Both userId and walletAddress are required",
        received: { userId, walletAddress: rawAddress }
      });
    }

    // Convert and validate wallet address format
    let processedAddress;
    try {
      if (rawAddress.startsWith('0:')) {
        processedAddress = 'EQ' + rawAddress.substring(2);
      } else if (rawAddress.startsWith('EQ') || rawAddress.startsWith('UQ')) {
        processedAddress = rawAddress;
      } else {
        return res.status(400).json({ 
          error: "Wallet address must start with 0:, EQ, or UQ",
          received: rawAddress
        });
      }

      // Enhanced TON address validation
      const tonRegex = /^(EQ|UQ)[a-zA-Z0-9_-]{43,}$/;
      if (!tonRegex.test(processedAddress)) {
        return res.status(400).json({ 
          error: "Invalid TON wallet address format",
          received: rawAddress,
          processed: processedAddress
        });
      }
    } catch (e) {
      return res.status(400).json({ 
        error: "Failed to process wallet address",
        details: e.message 
      });
    }

    // Validate and parse userId
    const parsedUserId = parseInt(userId);
    if (isNaN(parsedUserId)) {
      return res.status(400).json({ 
        error: "userId must be a valid number",
        received: userId
      });
    }

    // Check for existing wallet connection
    try {
      const existingUser = await User.findOne({ 
        'tonWallet.address': processedAddress,
        userId: { $ne: parsedUserId }
      });
      
      if (existingUser) {
        return res.status(400).json({ 
          error: "This wallet is already connected to another account",
          existingUserId: existingUser.userId
        });
      }
    } catch (dbError) {
      console.error('Database lookup error:', dbError);
      return res.status(500).json({ 
        error: "Error checking wallet ownership",
        details: dbError.message
      });
    }

    // Update user record
    try {
      const result = await User.updateOne(
        { userId: parsedUserId },
        { 
          $set: { 
            'tonWallet.address': processedAddress,
            'tonWallet.connectedAt': new Date(),
            'tonWallet.rawAddress': rawAddress // Store original for reference
          } 
        },
        { upsert: true }
      );

      if (result.modifiedCount === 0 && result.upsertedCount === 0) {
        return res.status(500).json({ 
          error: "No documents were modified or created",
          details: result
        });
      }

      return res.json({ 
        success: true,
        message: "Wallet saved successfully",
        address: processedAddress,
        rawAddress: rawAddress,
        userId: parsedUserId
      });

    } catch (updateError) {
      console.error('Update error:', updateError);
      if (updateError.code === 11000) {
        return res.status(400).json({ 
          error: "Duplicate wallet connection detected",
          details: updateError.message
        });
      }
      return res.status(500).json({ 
        error: "Failed to update user record",
        details: updateError.message
      });
    }

  } catch (err) {
    console.error('Unexpected error:', err);
    return res.status(500).json({ 
      error: "Internal server error",
      details: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }
});
// Wallet disconnection endpoint
app.post('/api/disconnect-wallet', express.json(), async (req, res) => {
  try {
    const { userId } = req.body;
    
    await User.updateOne(
      { userId: parseInt(userId) },
      { 
        $set: { 
          'tonWallet.address': '',
          'tonWallet.connectedAt': null,
          'tonWallet.isTelegramWallet': false
        } 
      }
    );

    res.json({ success: true });
    
  } catch (err) {
    res.status(500).json({ error: "Failed to disconnect wallet" });
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`âœ… Server listening on port ${PORT}`);
});


// Error Handling
bot.catch((err) => {
  console.error('Bot error:', err);
});


// Graceful Shutdown
process.once('SIGINT', () => {
  mongoose.connection.close();
  bot.stop('SIGINT');
});
process.once('SIGTERM', () => {
  mongoose.connection.close();
  bot.stop('SIGTERM');
});


// Start server
app.listen(PORT, () => {
  console.log(`âœ… Server listening on port ${PORT}`);
}).on('error', (err) => {
  console.error('Server error:', err);
  if (err.code === 'EADDRINUSE') {
    console.log(`Port ${PORT} is busy, trying another...`);
    app.listen(0, () => { // 0 = random available port
      console.log(`âœ… Server listening on new port`);
    });
  }
});
